# Dataset methods

Once you have [imported your Dataset](../io/#titration-metadata-dataset) (as `ds` in the example code below) and made sure it has [the necessary columns, named correctly](../metadata/#dataset-column-names), you can use a series of different functions or methods to calibrate the titrant and solve the samples for alkalinity.

!!! question "Methods or functions?"

    All the methods mentioned here operate on the Dataset in-place, but are also available as functions at the top-level, in case you prefer that syntax.  The method approach is recommended:

    ```python
    ds.calkulate()
    ```

    But you could also achieve the same thing with the function approach, if you prefer:

    ```
    ds = calk.calkulate(ds)
    ```

## Do everything at once with `calkulate`...

The method `calkulate` does *everything:*

```python
ds.calkulate()
```

If you need to provide any [extra kwargs for reading the titration data files](../io/#dealing-with-other-formats), you should do that here as a dict:

```python
read_dat_kwargs = dict(
    # whatever kwargs you need...
)
ds.calkulate(read_dat_kwargs=read_dat_kwargs)
```

## ... or do it step-by-step

But what do we mean by *everything?*  Here's a break-down of the individual steps that are part of `ds.calkulate()`, which you can also run yourself separately if you prefer.

### Import individual titrations' data

```python
ds.get_titrations(read_dat_kwargs=None)
```

Adds a column `titration` that contains the full titration data for each file, imported from the individual text files.

A warning will print for any files that can't be found or imported, but this won't cause an error — the code will continue to run.

You should provide any [extra kwargs needed for reading your titration data files](../io/#dealing-with-other-formats) as a dict.

### Import and prepare for calibration and solving

```python
ds.prepare(read_dat_kwargs=None)
```

Runs `ds.get_titrations()`, converts analyte and titrant to volumes to masses, and calculates total salt molinities (accounting for dilution by the titrant) and equilibrium constants throughout each titration.

As always, you should provide any [extra kwargs needed for reading your titration data files](../io/#dealing-with-other-formats) as a dict.

### Calibrate titrant molinity

```python
ds.calibrate()
```

For each titration (i.e. row in the Dataset) that has an [`alkalinity_certified` value](../metadata/#recommended-columns), this method determines the titrant molinity (in mol/kg-solution) that is required for the titration to return its certified alkalinity value.  This is stored in a new column in the Dataset called `titrant_molinity_here`.

Then, the `titrant_molinity_here` values are averaged — [by `analysis_batch`](../metadata/#recommended-columns) if provided, or over the entire Dataset if not — and stored in a new column called `titrant_molinity`.

### Solve samples for alkalinity

```python
ds.solve()
```

For each titration (i.e. row in the Dataset) that has an `titrant_molinity` value (e.g. as generated by `ds.calibrate()` above), this method determines its total alkalinity in μmol/kg-solution.  The results are stored in a new column in the Dataset called `alkalinity`.

## Why break it up?

You may wish to use the step-by-step approach if you need to do any intermediate processing.  For example, if the approach of taking the mean titrant molinity for each analysis batch is not appropriate to your dataset, you could do:

```python
import calkulate as calk

# Import data and calibrate individual titrant molinities
ds = calk.read_excel("path/to/metadata_file.xlsx").prepare().calibrate()

# Update the titrant molinity values to whatever they should be
ds["titrant_molinity"] = ...

# Solve for alkalinity
ds.solve()
```

Alternatively, if your metadata is coming from a VINDTA dbs file, you may need to add extra columns to it before processing:

```python
# Import metadata
ds = calk.read_dbs("path/to/metadata_file.dbs")

# Add extra columns
ds["analysis_batch"] = ...
ds["alkalinity_certified"] = ...
# etc.

# Calkulate!
ds.calkulate()
```
